+--------------+
| ./date.swift |
+--------------+
// Will also return rollover dates for "wrong" input components
//
// About date values in Swift:
// `Date` values are always converted to unified standard of the UTC timezone
// We can specify, when inputting a date, to ensure we note the UTC equivalent of our own timezone
// This way, we input our local date/time, and the UTC value will be adjusted to respect it
// However, this means that dates are *always* stored as UTC
// This causes no problems for passing `Date` types around, since these will adhere to our equivalent
// But when Formatting a date, we must instruct Swift to use our specific timezone, again, to display it in
// This way, we will be able to see the value--if all is correct--that we originally put in
//
import Foundation

// Set timezone variable
public enum CustomTimeZone: String {
    case utc = "UTC"
    
    // North America
    case hawaii = "Pacific/Honolulu"         // UTC-10
    case alaska = "America/Anchorage"         // UTC-9
    case pacific = "America/Los_Angeles"        // UTC-8
    case mountain = "America/Denver"          // UTC-7
    case central = "America/Chicago"          // UTC-6
    case eastern = "America/New_York"         // UTC-5
    case atlantic = "America/Halifax"         // UTC-4
    
    // South America
    case brazil = "America/Sao_Paulo"         // UTC-3
    
    // Europe & Africa
    case london = "Europe/London"             // UTC+0
    case amsterdam = "Europe/Amsterdam"       // UTC+1
    case athens = "Europe/Athens"             // UTC+2
    case moscow = "Europe/Moscow"             // UTC+3
    
    // Middle East & South Asia
    case dubai = "Asia/Dubai"                 // UTC+4
    case kolkata = "Asia/Kolkata"             // UTC+5:30
    case dhaka = "Asia/Dhaka"                 // UTC+6
    
    // Southeast Asia
    case bangkok = "Asia/Bangkok"             // UTC+7
    case hongKong = "Asia/Hong_Kong"           // UTC+8
    
    // East Asia & Oceania
    case tokyo = "Asia/Tokyo"                 // UTC+9
    case sydney = "Australia/Sydney"          // UTC+10
    case auckland = "Pacific/Auckland"        // UTC+12
    
    var set: TimeZone {
        return TimeZone(identifier: self.rawValue) ?? TimeZone.current
    }
}

public enum DateConversionError: Error {
    case invalidDateComponents
    case invalidStringPassed
}

func defaultDate() -> Date {
    let calendar = Calendar(identifier: .gregorian)
    let defaultComponents = DateComponents(year: 1, month: 1, day: 1, hour: 0, minute: 0, second: 0)
    let defaultDate = calendar.date(from: defaultComponents)!
    return defaultDate
}

// DateComponents -> Date
public protocol DateConvertible {
    func toDate(using calendar: Calendar,_ timezone: CustomTimeZone) -> Date
}

extension DateComponents: DateConvertible {
    public func toDate(using calendar: Calendar = .current,_ timezone: CustomTimeZone = .amsterdam) -> Date {
        var calendar = calendar
        calendar.timeZone = timezone.set

        if let date = calendar.date(from: self) {
            return date
        } else {
            return defaultDate()
        }
    }
}

// String -> DateComponents
public protocol DateRetrievable {
    func date(_ timezone: CustomTimeZone) -> Date
}

extension String {
    public func date(_ timezone: CustomTimeZone = .amsterdam) -> Date {
        let components = self.split(separator: "-")

        guard components.count == 3,
            components[0].count == 4,
            components[1].count == 2,
            components[2].count == 2,
            let year = Int(components[0]), 
            let month = Int(components[1]), 
            let day = Int(components[2]) else {
            return defaultDate()
        }
        
        var dateComponents = DateComponents()
        dateComponents.year = year
        dateComponents.month = month
        dateComponents.day = day

        return dateComponents.toDate(timezone) // will either return date from inputs or defaultDate() value
    }
}

// Formatted date with correct timezone display
public protocol Formattable {
    func format(to timezone: CustomTimeZone,_ style: DateStyle) -> String
}

public enum DateStyle {
    case date
    case dateTime
}

extension Date: Formattable {
    public func format(to timezone: CustomTimeZone = .amsterdam,_ style: DateStyle = .dateTime) -> String {
        let formatter = DateFormatter()
        formatter.timeZone = timezone.set
        
        switch style {
            case .date: 
            formatter.dateFormat = "yyyy-MM-dd"
            case .dateTime: 
            formatter.dateFormat = "yyyy-MM-dd HH:mm:ss ZZZZ"
        }
        return formatter.string(from: self)
    }
}
(!): 2 blank lines

+----------------+
| ./indent.swift |
+----------------+
import Foundation

public protocol StringIndentable {
    func indent(_ indentation: Int) -> String
}

extension String: StringIndentable {
    public func indent(_ indentation: Int = 4) -> String { 
        let indent = String(repeating: " ", count: indentation)

        return self
            .split(separator: "\n") // Split the string into lines
            .map { "\(indent)\($0)" } // Add indentation to each line
            .joined(separator: "\n") // Combine lines back into a single string
    }
}
(!): 2 blank lines

+---------------+
| ./ascii.swift |
+---------------+
import Foundation

public let asciiLetters: [Character: [String]] = [
    "A": ["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
    "B": ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
    "C": [" CCC ", "C   C", "C    ", "C   C", " CCC "],
    "D": ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
    "E": ["EEEEE", "E    ", "EEE  ", "E    ", "EEEEE"],
    "F": ["FFFFF", "F    ", "FFF  ", "F    ", "F    "],
    "G": [" GGG ", "G    ", "G  GG", "G   G", " GGG "],
    "H": ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
    "I": ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
    "J": ["JJJJJ", "    J", "    J", "J   J", " JJJ "],
    "K": ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
    "L": ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
    "M": ["M   M", "MM MM", "M M M", "M   M", "M   M"],
    "N": ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
    "O": [" OOO ", "O   O", "O   O", "O   O", " OOO "],
    "P": ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
    "Q": [" QQQ ", "Q   Q", "Q   Q", "Q  Q ", " QQ Q"],
    "R": ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
    "S": [" SSS ", "S    ", " SSS ", "    S", " SSS "],
    "T": ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
    "U": ["U   U", "U   U", "U   U", "U   U", " UUU "],
    "V": ["V   V", "V   V", "V   V", " V V ", "  V  "],
    "W": ["W   W", "W   W", "W W W", "WW WW", "W   W"],
    "X": ["X   X", " X X ", "  X  ", " X X ", "X   X"],
    "Y": ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
    "Z": ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"],
    "0": [" 000 ", "0   0", "0   0", "0   0", " 000 "],
    "1": ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
    "2": [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
    "3": [" 333 ", "3   3", "   3 ", "3   3", " 333 "],
    "4": ["4  4 ", "4  4 ", "44444", "   4 ", "   4 "],
    "5": ["55555", "5    ", "5555 ", "    5", "5555 "],
    "6": [" 666 ", "6    ", "6666 ", "6   6", " 666 "],
    "7": ["77777", "   7 ", "  7  ", " 7   ", "7    "],
    "8": [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
    "9": [" 999 ", "9   9", " 9999", "    9", " 999 "],
    " ": ["     ", "     ", "     ", "     ", "     "]
]

public func asciify(_ text: String) {
    let uppercased = text.uppercased()
    var output = ["", "", "", "", ""]

    for char in uppercased {
        if let asciiLines = asciiLetters[char] {
            for (index, line) in asciiLines.enumerated() {
                output[index] += line + "  "
            }
        } else {
            for index in 0..<5 {
                output[index] += "     "  // Space for unsupported characters
            }
        }
    }

    for line in output {
        print(line)
    }
}

public protocol ASCIIable {
    func ascii() -> String
}

extension String: ASCIIable {
    public func ascii() -> String {
        let uppercased = self.uppercased()
        var output = ["", "", "", "", ""]

        for char in uppercased {
            if let asciiLines = asciiLetters[char] {
                for (index, line) in asciiLines.enumerated() {
                    output[index] += line + "  "
                }
            } else {
                for index in 0..<5 {
                    output[index] += "     "  // Space for unsupported characters
                }
            }
        }

        var string = ""
        
        for line in output {
            string.append("\(line)\n")
        }

        return string
    }
}
(!): 3 blank lines

+-------------------------+
| ./network-request.swift |
+-------------------------+
import Foundation

public func requestHTTP(
    url: URL,
    httpMethod: String,
    headers: [String: String]? = nil,
    body: Data?,
    logDebug: Bool = false,
    completion: @escaping @Sendable (Bool, Data?, Error?) -> Void
) {
    var request = URLRequest(url: url)
    request.httpMethod = httpMethod
    headers?.forEach { request.addValue($1, forHTTPHeaderField: $0) }
    request.httpBody = body
    request.timeoutInterval = 60

    URLSession.shared.dataTask(with: request) { data, response, error in
        if logDebug, let httpResponse = response as? HTTPURLResponse {
            print("HTTP Status Code: \(httpResponse.statusCode)")
            print("Response Headers: \(httpResponse.allHeaderFields)")
        }

        if let error = error {
            completion(false, nil, error)
            return
        }

        guard let data = data, let httpResponse = response as? HTTPURLResponse, (200..<300).contains(httpResponse.statusCode) else {
            let statusError = NSError(
                domain: "HTTPError",
                code: (response as? HTTPURLResponse)?.statusCode ?? -1,
                userInfo: [NSLocalizedDescriptionKey: "Request failed"]
            )
            completion(false, nil, statusError)
            return
        }

        completion(true, data, nil)
    }.resume()
}

+---------------+
| ./align.swift |
+---------------+
import Foundation

public enum Alignment {
    case left
    case right
}

public protocol Alignable {
    func align(_ side: Alignment,_ width: Int) -> String
}

extension String: Alignable {
    // example use -> "This is a string".align(.left, 50)
    public func align(_ side: Alignment,_ width: Int = 80) -> String {
        let padding = max(0, width - self.count)

        switch side {
        case .left:
            let paddedText = self + String(repeating: ".", count: padding)
            return paddedText
        case .right:
            let paddedText = String(repeating: ".", count: padding) + self
            return paddedText
        }
    }
}
(!): 3 blank lines

+----------------+
| ./spacer.swift |
+----------------+
import Foundation
// Spacer functions

// Basic:
public func printSpacerBasic(_ lines: Int) {
    var reps = lines

    while reps != 0 {
        print("")
        reps -= 1
    }
}

// Defining particular characters and printing a set length 

// Setting up an enumeration
public enum LineStyle: Sendable {
    case blank
    case hash
    case line
    case dot
}

// Using enumeration as argument, involving a predefined length
public func printSpacer(_ lines: Int = 1, _ style: LineStyle? = .blank,_ length: Int = 80) {
    var reps = lines 

    while reps != 0 {
        switch style {
            case .blank, .none:
            print(String(repeating: "", count: length))
            case .hash:
            print(String(repeating: "#", count: length))
            case .line:
            print(String(repeating: "-", count: length))
            case .dot:
            print(String(repeating: ".", count: length))
        }
        reps -= 1
    }
}

public struct Divider {
    public let separator: LineStyle 
    public let separatorLines: Int 
    public let length: Int
    public let whitelines: Int 

    public init(separator: LineStyle, separatorLines: Int, length: Int, whitelines: Int) {
        self.separator = separator
        self.separatorLines = separatorLines
        self.length = length
        self.whitelines = whitelines
    }
}

public func makeDividerFromConfig(_ dividerConfig: Divider) -> () -> Void {
    return {
        let div = dividerConfig

        printSpacer(div.whitelines, .blank)
        printSpacer(div.separatorLines, div.separator, div.length)
        printSpacer(div.whitelines, .blank)
    }
}

public func defaultDivider() { 
    let dividerConfig: Divider = Divider(
        separator: .line, 
        separatorLines: 1,
        length: 60,
        whitelines: 2
    )
    makeDividerFromConfig(dividerConfig)()
}

+------------------------+
| ./capitalization.swift |
+------------------------+
// uses ANSI
import Foundation

public enum Selection {
    case first
    case all
    case varied
}

public protocol Capitalization {
    func capitalize(_ selection: Selection) -> String
}

extension String: Capitalization {
    public func capitalize(_ selection: Selection) -> String {
        let normalized = self.lowercased()
        let enArticles = ["of", "from", "the", "a", "an", "in", "on", "with"]
        let nlArticles = ["van", "de", "der", "den", "het", "een"]
        let articles = Set(enArticles + nlArticles)  // Combine English and Dutch articles


        switch selection {
            case .first: 
                return normalized.prefix(1).uppercased() + self.dropFirst()
            case .all: 
                return normalized.split(separator: " ").map { $0.prefix(1).uppercased() + $0.dropFirst() }.joined(separator: " ")
            case .varied:
                return normalized.split(separator: " ").enumerated().map { index, word in
                    let wordStr = String(word)  // Convert Substring to String
                    if index == 0 || !articles.contains(wordStr) { // Capitalize first word and non-articles
                        return wordStr.prefix(1).uppercased() + wordStr.dropFirst()
                    } else {
                        return wordStr  // Keep articles in lowercase
                    }
                }.joined(separator: " ")
        }
    }
}
(!): 2 blank lines

+--------------+
| ./ansi.swift |
+--------------+
import Foundation

public enum ANSIColor: String {
    // Basic Text Formatting
    case reset = "\u{001B}[0m"
    case bold = "\u{001B}[1m"
    case dim = "\u{001B}[2m"
    case italic = "\u{001B}[3m"
    case underline = "\u{001B}[4m"
    case blink = "\u{001B}[5m"
    case inverse = "\u{001B}[7m"
    case hidden = "\u{001B}[8m"
    case strikethrough = "\u{001B}[9m"
    
    // Foreground Colors
    case black = "\u{001B}[30m"
    case red = "\u{001B}[31m"
    case green = "\u{001B}[32m"
    case yellow = "\u{001B}[33m"
    case blue = "\u{001B}[34m"
    case magenta = "\u{001B}[35m"
    case cyan = "\u{001B}[36m"
    case white = "\u{001B}[37m"
    case defaultText = "\u{001B}[39m"
    
    // Bright Foreground Colors
    case brightBlack = "\u{001B}[90m"
    case brightRed = "\u{001B}[91m"
    case brightGreen = "\u{001B}[92m"
    case brightYellow = "\u{001B}[93m"
    case brightBlue = "\u{001B}[94m"
    case brightMagenta = "\u{001B}[95m"
    case brightCyan = "\u{001B}[96m"
    case brightWhite = "\u{001B}[97m"
    
    // Background Colors
    case blackBackground = "\u{001B}[40m"
    case redBackground = "\u{001B}[41m"
    case greenBackground = "\u{001B}[42m"
    case yellowBackground = "\u{001B}[43m"
    case blueBackground = "\u{001B}[44m"
    case magentaBackground = "\u{001B}[45m"
    case cyanBackground = "\u{001B}[46m"
    case whiteBackground = "\u{001B}[47m"
    case defaultBackground = "\u{001B}[49m"
    
    // Bright Background Colors
    case brightBlackBackground = "\u{001B}[100m"
    case brightRedBackground = "\u{001B}[101m"
    case brightGreenBackground = "\u{001B}[102m"
    case brightYellowBackground = "\u{001B}[103m"
    case brightBlueBackground = "\u{001B}[104m"
    case brightMagentaBackground = "\u{001B}[105m"
    case brightCyanBackground = "\u{001B}[106m"
    case brightWhiteBackground = "\u{001B}[107m"
    
    // Cursor Control
    case cursorUp = "\u{001B}[{n}A"
    case cursorDown = "\u{001B}[{n}B"
    case cursorRight = "\u{001B}[{n}C"
    case cursorLeft = "\u{001B}[{n}D"
    case cursorPosition = "\u{001B}[{line};{column}H"
    case clearLine = "\u{001B}[2K"
    case clearScreen = "\u{001B}[2J"

    public static func rgb(_ r: Int,_ g: Int,_ b: Int, _ background: Bool = false) -> String {
        if !background {
            return "\u{001B}[38;2;\(r);\(g);\(b)m"
        } else {
            return "\u{001B}[48;2;\(r);\(g);\(b)m"
        }
    }
}

public protocol StringANSIFormattable {
    func ansi(_ colors: ANSIColor...) -> String
    func ansiRGB(_ r: Int, _ g: Int, _ b: Int, _ background: Bool) -> String
}

extension String: StringANSIFormattable {
    public func ansi(_ colors: ANSIColor...) -> String {
        let colorCodes = colors.map { $0.rawValue }.joined()
        return "\(colorCodes)\(self)\(ANSIColor.reset.rawValue)"
    }

    public func ansiRGB(_ r: Int, _ g: Int, _ b: Int, _ background: Bool = false) -> String {
        let colorCode = ANSIColor.rgb(r, g, b, background)
        return "\(colorCode)\(self)\(ANSIColor.reset.rawValue)"
    }
}

+-------------------+
| ./printable.swift |
+-------------------+
import Foundation

protocol Printable {
    func prnt()
}

extension String: Printable {
    func prnt() { 
        print(self)
    }
}
(!): 2 blank lines

+-----------------------+
| ./convert-types.swift |
+-----------------------+
import Foundation

func convertDictionaryToSet(_ dictionary: [String: String], output: String) -> Set<String> {
    switch output.lowercased() {
    case "keys", "a", "first":
        return Set(dictionary.keys)
    case "values", "b", "second":
        return Set(dictionary.values)
    default:
        print("Invalid argument. Please specify 'keys' or 'values'.")
        return []
    }
}

+--------------+
| ./json.swift |
+--------------+
import Foundation

public func loadDataFromFile(_ filePath: String) -> Data? {
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)) else {
        print("Error: Could not load Data from file at \(filePath)")
        return nil
    }
    return data
}

public func decodeJSON<T: Decodable>(_ data: Data, as type: T.Type) -> T? {
    let decoder = JSONDecoder()
    do {
        let parsedData = try decoder.decode(T.self, from: data)
        return parsedData
    } catch {
        print("Error: Failed to decode JSON - \(error)")
        return nil
    }
}

+-------------+
| ./vat.swift |
+-------------+
import Foundation

public enum VAT {
    case vat
    case revenue
}

public protocol ValueAddedTaxableDouble {
    func vat(_ vatRate: Int, _ calculatedValue: VAT) -> Double
}

public protocol ValueAddedTaxableInt {
    func vat(_ vatRate: Int, _ calculatedValue: VAT) -> Int
}

extension Double: ValueAddedTaxableDouble {
    public func vat(_ vatRate: Int = 21, _ calculatedValue: VAT = .vat) -> Double {
        let vatRateDouble = Double(vatRate)
        switch calculatedValue {
        case .vat:
            return (self / (100.0 + vatRateDouble)) * vatRateDouble
        case .revenue:
            return (self / (100.0 + vatRateDouble)) * 100.0
        }
    }
}

extension Int: ValueAddedTaxableInt {
    public func vat(_ vatRate: Int = 21, _ calculatedValue: VAT = .vat) -> Int {
        let doubleValue = Double(self)
        let vatRateDouble = Double(vatRate)
        let result: Double
        
        switch calculatedValue {
        case .vat:
            result = (doubleValue / (100.0 + vatRateDouble)) * vatRateDouble
        case .revenue:
            result = (doubleValue / (100.0 + vatRateDouble)) * 100.0
        }
        
        return Int(result.rounded())
    }
}

+------------------+
| ./rounding.swift |
+------------------+
import Foundation

// Function to round a Double and return an Int
public func roundedToInt(_ value: Double) -> Int {
    return Int(value.rounded())
}

// Extension to round double to specified decimal places
extension Double {
    public func rounded(toPlaces places: Int) -> Double {
        let divisor = pow(10.0, Double(places))
        return (self * divisor).rounded() / divisor
    }
}

// protocol that takes argument to round to
public protocol Roundable {
    func roundTo(_ multiple: Self) -> Self
}

// Extension for Double
extension Double: Roundable {
    public func roundTo(_ multiple: Double) -> Double {
        return (self / multiple).rounded() * multiple
    }
}

// Extension for Int
extension Int: Roundable {
    public func roundTo(_ multiple: Int) -> Int {
        return ((self / multiple) * multiple)
    }
}

+-------------+
| ./box.swift |
+-------------+
import Foundation

public func stripANSI(_ string: String) -> String {
    return string.replacingOccurrences(of: "\u{001B}\\[[0-9;]*[a-zA-Z]", with: "", options: .regularExpression)
}

public func createBox(for content: String) -> String {
    let lines = content.split(separator: "\n")
    
    let strippedLines = lines.map { stripANSI(String($0)) }
    let maxLength = strippedLines.map { $0.count }.max() ?? 0
    
    let horizontalBorder = "+" + String(repeating: "-", count: maxLength + 2) + "+"
    var boxedContent = horizontalBorder + "\n"
    
    for (index, line) in lines.enumerated() {
        let strippedLine = strippedLines[index]
        let paddingCount = maxLength - strippedLine.count
        let paddedLine = line + String(repeating: " ", count: paddingCount)
        boxedContent += "| \(paddedLine) |\n"
    }
    
    boxedContent += horizontalBorder
    return boxedContent
}

+-------------------------+
| ./case-conversion.swift |
+-------------------------+
import Foundation
// Camel and Snake conversion of parameter names

// Helper to convert camelCase to snake_case
public func convertToSnakeCase(_ input: String) -> String {
    let regex = try! NSRegularExpression(pattern: "([a-z0-9])([A-Z])")
    let range = NSRange(location: 0, length: input.utf16.count)
    let snakeCaseName = regex.stringByReplacingMatches(
        in: input,
        options: [],
        range: range,
        withTemplate: "$1_$2"
    ).lowercased()
    return snakeCaseName
}

// Helper to convert snake_case to camelCase
public func convertToCamelCase(_ input: String) -> String {
    let components = input.split(separator: "_")
    guard let first = components.first?.lowercased() else { return input }
    let camelCased = components.dropFirst().map { $0.capitalized }.joined()
    return first + camelCased
}

// Generalized protocol
public protocol CamelSnakeConvertible {
    func snake() -> String
    func camel() -> String
}

// Implementation for Enum type arguments
extension CamelSnakeConvertible where Self: RawRepresentable, Self.RawValue == String {
    public func snake() -> String {
        return convertToSnakeCase(rawValue)
    }

    public func camel() -> String {
        return convertToCamelCase(rawValue)
    }
}

// Implementation for String type arguments
extension String {
    public func snake() -> String {
        return convertToSnakeCase(self)
    }

    public func camel() -> String {
        return convertToCamelCase(self)
    }
}

// Implementation for CodingKey
extension CodingKey {
    public var snakeCase: String {
        return convertToSnakeCase(stringValue)
    }
    
    public var camelCase: String {
        return convertToCamelCase(stringValue)
    }
}

// For either case, but always with Encoder
extension JSONEncoder {
    public static func snakeCaseEncoder() -> JSONEncoder {
        let encoder = JSONEncoder()
        encoder.keyEncodingStrategy = .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToSnakeCase(lastKey))!
        }
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }

    public static func camelCaseEncoder() -> JSONEncoder {
        let encoder = JSONEncoder()
        encoder.keyEncodingStrategy = .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToCamelCase(lastKey))!
        }
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }
}

// For either case, but always with Decoder
extension JSONDecoder {
    public static func snakeCaseDecoder() -> JSONDecoder {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToCamelCase(lastKey))!
        }
        return decoder
    }

    public static func camelCaseDecoder() -> JSONDecoder {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToSnakeCase(lastKey))!
        }
        return decoder
    }
}

// Define a generic CodingKey that allows dynamic key conversion
public struct AnyKey: CodingKey {
    public var stringValue: String
    public var intValue: Int?

    public init?(stringValue: String) {
        self.stringValue = stringValue
        self.intValue = nil
    }

    public init?(intValue: Int) {
        self.stringValue = "\(intValue)"
        self.intValue = intValue
    }
}

public struct CustomStrategies {
    /// Encodes camelCase property names to snake_case keys in JSON
    public static func encodeCamelToSnake() -> JSONEncoder.KeyEncodingStrategy {
        return .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToSnakeCase(lastKey))!
        }
    }
    
    /// Encodes snake_case property names to camelCase keys in JSON
    public static func encodeSnakeToCamel() -> JSONEncoder.KeyEncodingStrategy {
        return .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToCamelCase(lastKey))!
        }
    }
    
    /// Decodes snake_case keys from JSON to camelCase property names in structs
    public static func decodeFromSnakeToCamel() -> JSONDecoder.KeyDecodingStrategy {
        return .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToCamelCase(lastKey))!
        }
    }
    
    /// Decodes camelCase keys from JSON to snake_case property names in structs
    public static func decodeFromCamelToSnake() -> JSONDecoder.KeyDecodingStrategy {
        return .custom { keys in
            let lastKey = keys.last!.stringValue
            return AnyKey(stringValue: convertToSnakeCase(lastKey))!
        }
    }
}

public protocol QuicklyEncodable: Encodable {}
public protocol QuicklyDecodable: Decodable {}

extension Data {
    public func toJSONString(encoding: String.Encoding = .utf8) -> String? {
        return String(data: self, encoding: encoding)
    }
}

extension QuicklyEncodable {
    public func quickEncode(
        encodingStrategy: JSONEncoder.KeyEncodingStrategy = CustomStrategies.encodeCamelToSnake(),
        outputFormatting: JSONEncoder.OutputFormatting = .prettyPrinted
    ) -> String? {
        do {
            let encoder = JSONEncoder()
            encoder.keyEncodingStrategy = encodingStrategy
            encoder.outputFormatting = outputFormatting
            let data = try encoder.encode(self)
            return data.toJSONString()
        } catch {
            print("Encoding failed with error: \(error)")
            return nil
        }
    }
}

extension QuicklyDecodable {
    public static func quickDecode(
        from jsonString: String,
        decodingStrategy: JSONDecoder.KeyDecodingStrategy = CustomStrategies.decodeFromSnakeToCamel()
    ) -> Self? {
        do {
            guard let data = jsonString.data(using: .utf8) else { return nil }
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = decodingStrategy
            return try decoder.decode(Self.self, from: data)
        } catch {
            print("Decoding failed with error: \(error)")
            return nil
        }
    }
}

+----------------+
| ./dotenv.swift |
+----------------+
import Foundation

public struct DotEnv {
    private let filePath: String

    public init(traverse: Int = 0, path: String = ".env") {
        var finalPath = ""
        var traversals = traverse

        while traversals > 0 {
            finalPath.append("../")
            traversals -= 1
        }

        finalPath.append(path)
        self.filePath = finalPath
    }

    public func load() throws {
        let fileURL = URL(fileURLWithPath: filePath)

        let contents = try String(contentsOf: fileURL, encoding: .utf8)

        for line in contents.split(separator: "\n") {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)

            guard !trimmed.isEmpty, !trimmed.hasPrefix("#") else {
                continue
            }

            let parts = trimmed.split(separator: "=", maxSplits: 1).map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            if parts.count == 2 {
                setenv(parts[0], parts[1], 1)
            }
        }
    }
}

+---------------+
| ./debug.swift |
+---------------+
// uses ANSI
import Foundation

enum DebugClass: String {
    case info = "INFO"
    case warn = "WARNING"
    case err = "ERROR"
}

protocol Debuggable {
    func debug(_ debugClass: DebugClass,_ debugModeActive: Bool)
}

extension String: Debuggable {
    func debug(_ debugClass: DebugClass,_ debugModeActive: Bool) {
        if debugModeActive == true {
            switch debugClass {
                case .info:
                    print("[\(debugClass.rawValue)]: \(self)".ansi(.brightBlack))
                case .warn:
                    print("[\(debugClass.rawValue)]: \(self)".ansi(.yellow))
                case .err:
                    print("[\(debugClass.rawValue)]: \(self)".ansi(.red))
            }
        }
    }
}

+-------------------+
| ./clipboard.swift |
+-------------------+
import Foundation
import AppKit

// as function calls, backwards compatibility
public func copyToClipboard(_ text: String) {
    let pasteboard = NSPasteboard.general
    pasteboard.clearContents()
    pasteboard.setString(text, forType: .string)
}

// was the same as copyToClipboard, may need refactoring in places where this name called NSAttributed strings
public func copyNSToClipboard(_ attributedString: NSAttributedString) {
    let pasteboard = NSPasteboard.general
    pasteboard.clearContents()
    pasteboard.writeObjects([attributedString])
}

// now also as protocols
public protocol StringCopyable {
    func sCopy()
}

extension String: StringCopyable {
    public func sCopy() {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(self, forType: .string)

    }
}

public protocol NSAttributedStringCopyable {
    func nsCopy()
}

extension NSAttributedString: NSAttributedStringCopyable {
    public func nsCopy() {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.writeObjects([self])

    }
}

+----------------+
| ./bundle.swift |
+----------------+
// for getting a Resource from resources bundle quickly without specifying a bunch of things
// just pass a single file string
import Foundation

func getResource(_ resource: String) -> String {
    let components = resource.split(separator: ".")

    guard components.count == 2 else {
        print("Error: Invalid resource name format. Use 'filename.extension'.")
        return ""
    }

    let filename = String(components[0])
    let filetype = String(components[1])

    // return Bundle.module.path(forResource: filename, ofType: filetype) ?? ""
    return Bundle.main.path(forResource: filename, ofType: filetype) ?? ""
}

+---------------+
| ./plate.swift |
+---------------+
// The Swift Programming Language
// https://docs.swift.org/swift-book